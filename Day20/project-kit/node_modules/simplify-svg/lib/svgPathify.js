'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _cheerio = require('cheerio');

var _cheerio2 = _interopRequireDefault(_cheerio);

var _svgShapes = require('svg-shapes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var s2pTags = ['circle', 'ellipse', 'line', 'polygon', 'polyline', 'rect'];

var parseFloatAttrs = function parseFloatAttrs() {
  var attrs = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  return Object.keys(attrs).reduce(function (finalAttrs, key) {
    return _extends({}, finalAttrs, _defineProperty({}, key, key === 'points' ? attrs[key] : parseFloat(attrs[key], 10)));
  }, {});
};

var convertShapeToPath = function convertShapeToPath($) {
  s2pTags.forEach(function (tag) {
    var $elm = $(tag);

    $elm.each(function (index, element) {
      var $element = $(element);
      var attrs = $element.attr();
      var pathPoints = (0, _svgShapes.getPoints)(tag, parseFloatAttrs(attrs));
      var path = (0, _svgShapes.toPath)(pathPoints);
      var $path = $('<path/>');

      $path.attr('d', path);
      $path.attr(attrs);

      $element.replaceWith($path);
    });
  });
};

var svgPathify = function svgPathify(codeString) {
  return new Promise(function (resolve) {
    var $ = _cheerio2.default.load(codeString, {
      xmlMode: true
    });
    convertShapeToPath($);
    resolve($.html('svg'));
  });
};

exports.default = svgPathify;